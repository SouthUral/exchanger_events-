package consumermanagement

import (
	api "github.com/SouthUral/exchangeTest/api/api_v1"
	rt "github.com/SouthUral/exchangeTest/router"
)

// Инициализирует менеджера получателей, который управляет внутренними получателями
func InitConsManager(apiCh <-chan api.SubMess, subCh chan<- rt.SubscriberMess) func() {
	storageInfoCons := make(map[string]internalConsum)
	done := make(chan struct{})
	cancel := func() {
		close(done)
	}
	go func() {
		for {
			select {
			case mess := <-apiCh:
				// прием сообщение от API gRPC
				switch mess.TypeMess {

				case api.ConnectingConsumer:
					// тип сообщения (подключение потребителя)
					// TODO: нужно реализовать проверки конфига, есть ли уже работающий внутренний потребитель с таким конфигом
					// TODO: если конфиг найден, нужна проверка, есть ли этого конфига такой подписчик, если нет, то нужно создать подписчика
					// TODO: если подписчик есть, нужна проверка в каком он состоянии, если подписчик активен, то нужно отправить ошибку, что такой подписчик уже есть.
					// TODO: если подписчик есть и он не активен, то нужно привязать канал к этому подписчику и перевести подписчика в состояние активен

				case api.StoppingSending:
					// тип сообщения (остановка отправления событий)
					// перевод подписчика в состояние ожидания

				}
			case <-done:
				return
			}
		}
	}()
	// TODO: должен принимать канал для связи с сервером, по которому будут передаваться данные о новых потребителях или об их остановке
	// TODO: должен принимать канал для связи с API для управления и мониторинга получателей
	// TODO: должен принимать канал для отрпавки сообщений регистрации получателей в маршрутизаторе
	return cancel
}

// Промежуточный потребитель или очередь конкретного подписчика
// Может иметь два состояние, активное и неактивное, в неактичном состоянии просто сохраняет события в очереди
func queueConsumer() {

}
